# ğŸš€ Cloudhopper

**ğŸ—‘ï¸ You code, we take out the YAML.**  

## Why Cloudhopper?

Managing cloud functions sounds simple â€” until you're buried under a mountain of deployment files, integration classes, and cloud-specific configs. And every time you add a function, the pile gets bigger. Cloudhopper helps you escape that trap, so you can ship faster, and spend less time plumbing.

### ğŸ›‘ Stop copy-pasting deployment files

Terraform, OpenAPI specs, integration classes... every project ends up with hundreds of tiny variations and and it only takes one bad copy-paste to quietly burn your budget.  
Cloudhopper generates all of it automatically based on your code â€” consistent, reliable, and boring in the best possible way.

### ğŸ”„ Stop locking yourself into one cloud

Cloud-specific deployments are a trap.  
With Cloudhopper, your application stays platform-independent from day one.

### ğŸ§ª Try new cloud providers without rebuilding everything

Want to see if GCP or Azure would be faster, cheaper, or more reliable?  
Cloudhopper makes it easy to deploy the same app across different clouds.

### ğŸ¢ Offer on-premise deployments without the drama

Your customers wants an on-premise installation because of their policies, security, or regulations?  
Cloudhopper makes it easy to offer both cloud and on-prem options â€” from the same codebase.

## How it Works

Just use our simple Java API and add a few annotations.  
Cloudhopper takes care of:
- Generating the provider specific integration classes
- Generating infrastructure as code (terraform, saml, OpenAPI)
- Handling cloud-specific quirks
- Keeping your deployments repeatable, reliable, and boring

No boilerplate. No endless YAML. No regrets.

## Get Started

ğŸ‘‰ [Quickstart Guide](https://eppleton.github.io/cloudhopper-mc/)  
